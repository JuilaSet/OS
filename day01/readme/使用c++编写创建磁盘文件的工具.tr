/*
 * 使用c++编写创建磁盘文件的工具
 */
#def [text~]
====================
* 操作系统启动过程 {

	* CPU从默认位置开始执行BIOS {

		* 加电自检程序: (POST)是执行的第一个例行程序

		* 软件可以通过调用 BIOS 中断对软盘驱动器、键盘及显示器等外围设备进行管理

		* CMOS: BIOS 会根据在 CMOS 中保存的配置信息来判断使用哪种设备启动操作系统

	}

	* BIOS将磁盘上的`引导扇区`加载到物理内存(0x7c00处), 并跳转过去执行, 从而将 CPU 交给引导扇区中的 Boot 程序

	* `引导程序`会将存储设备中的`操作系统内核`载入内存, 并进入内核的入口点开始执行

	* `操作系统内核`完成系统的初始化

}

* 磁盘知识 {

	* 磁头: 2

	=> 磁道(柱面): 80

	=> 扇区: 512大小, 18个

}

* 汇编 {

	* `ORG`: 程序的起始地址
	|| ORG 0x7c00

	* 存储柱面号: 
	|| mov CH, 1 ;CH

	* 存储磁头号: 
	|| mov DH, 0 ;DH

	* 存储扇区号: 注意扇区号是从1开始计算的
	|| mov CL, 2 ;CL

	* 存放读取的数据位置: 
	|| mov BX, msg ; ES:BX

	* 表示要做的是读盘操作:
	|| mov AH, 0x02 ; AH = 02

	* 连续读取几个扇区: 
	|| mov AL, 1

	* 驱动器编号, 当前读取的是第几个软盘: 
	|| mov DL, 0

	* 调用BIOS中断实现磁盘读取功能: 
	|| INT 0x13

	* 读盘出现错误, 跳转到error处执行相应代码: 
	|| JC error

}

* 打印字符串 {

	* 打印字符串直到遇到0为止: 
	[ex~]
		[code] |<
		mov si, msg
	putloop:
		mov  al, [si]
		add  si, 1	; si指向下一个字符
		cmp  al, 0	; 是否遇到0
		je   fin
		mov  ah, 0x0e
		mov  bx, 15
		int  0x10	; 调用显示例程
		jmp  putloop
	fin: 
		...
	msg:
		"Hello OS"
		>| [uncode]

}
====================
